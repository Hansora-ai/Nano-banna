<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nano Banana — Image-to-Image</title>

  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 img-src * data: blob:;
                 connect-src 'self' https://api.kie.ai https://kieai.redpandaai.co https://hook.make.com;
                 style-src 'self' 'unsafe-inline';
                 script-src 'self' 'unsafe-inline' https://unpkg.com">
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <!-- EXIF (NEW: use full build so HEIC orientation is read) -->
  <script src="https://unpkg.com/exifr/dist/full.umd.js"></script>

  <!-- HEIC→JPEG converter -->
  <script src="https://unpkg.com/heic2any/dist/heic2any.min.js"></script>

  <style>
    body { background:#0b0b0f; color:#eaeaf0; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { max-width:880px; margin:40px auto; padding:24px; background:#14141b; border-radius:16px; box-shadow:0 8px 28px rgba(0,0,0,.45); }
    h1 { font-weight:700; font-size:24px; margin:0 0 12px; }
    .row{display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap}
    .col{flex:1 1 320px}
    label{display:block; font-size:13px; opacity:.85; margin-bottom:6px}
    input[type="file"], textarea, select { width:100%; background:#0f0f15; color:#eaeaf0; border:1px solid #262634; border-radius:12px; padding:10px 12px; }
    textarea{min-height:120px; resize:vertical}
    button{width:100%; padding:12px 16px; background:#6b5bd1; color:#fff; border:0; border-radius:12px; font-weight:600; cursor:pointer}
    button[disabled]{opacity:.6; cursor:not-allowed}
    #thumbs{display:flex; gap:8px; flex-wrap:wrap}
    .thumb{margin-top:8px; width:160px; height:160px; object-fit:cover; border-radius:10px; border:1px solid #262634}
    details{margin-top:16px; background:#0f0f15; border:1px solid #262634; border-radius:12px; padding:10px 12px}
    pre{white-space:pre-wrap; word-break:break-word; margin:0}

    .banner{margin-top:12px; padding:12px 14px; border-radius:12px; border:1px solid transparent; font-weight:600}
    .banner.ok{background:#0f1a12; border-color:#1f6d3d; color:#b9f3cf}
    .banner.err{background:#1a1110; border-color:#a24a4a; color:#ffd1d1}
  </style>
</head>
<body>
  <noscript><div style="background:#ffdbdb;color:#300;padding:10px;border-radius:8px">
    JavaScript is disabled. The Run button won’t work.
  </div></noscript>

  <div class="wrap">
    <h1>Nano Banana — Image-to-Image</h1>

    <div class="row">
      <div class="col">
        <label for="files">Select 1–4 images (jpeg/png/webp, ≤10MB each)</label>
        <input id="files" type="file" accept="image/*" multiple />
        <div id="thumbs"></div>
      </div>

      <div class="col">
        <label for="prompt">Prompt</label>
        <textarea id="prompt" placeholder="Describe the edit or style…"></textarea>
        <div style="height:10px"></div>
        <label for="format">Output format</label>
        <select id="format">
          <option value="png" selected>PNG</option>
          <option value="jpeg">JPEG</option>
        </select>

        <!-- Image size control (KIE tokens) -->
        <div style="height:10px"></div>
        <label for="imageSize">Image size</label>
        <select id="imageSize">
          <option value="auto" selected>Auto</option>
          <option value="1:1">Square (1:1)</option>
          <option value="3:4">Portrait 3:4</option>
          <option value="9:16">Portrait 9:16</option>
          <option value="4:3">Landscape 4:3</option>
          <option value="16:9">Landscape 16:9</option>
        </select>

        <div style="height:14px"></div>
        <button id="runBtn" type="button" onclick="window.__run && window.__run()">Run</button>
        <div id="status" class="banner" role="status" aria-live="polite" hidden></div>
      </div>
    </div>

    <details style="display:none">
      <summary>Debug</summary>
      <pre id="debug">BOOT: page parsed.</pre>
    </details>
  </div>

<script>
const dbg = document.getElementById('debug');
const log = (...a) => { dbg.textContent += '\n' + a.map(x=>typeof x==='string'?x:JSON.stringify(x,null,2)).join(' '); };
window.addEventListener('error', e => log('Window error:', e.message));
window.addEventListener('unhandledrejection', e => log('Unhandled promise:', String(e.reason)));

const filesEl = document.getElementById('files');
const thumbsEl= document.getElementById('thumbs');
const promptEl= document.getElementById('prompt');
const formatEl= document.getElementById('format');
const imageSizeEl = document.getElementById('imageSize');
const runBtn  = document.getElementById('runBtn');
const statusEl= document.getElementById('status');

function showStatus(msg, kind){
  statusEl.textContent = msg;
  statusEl.className = 'banner ' + (kind === 'ok' ? 'ok' : 'err');
  statusEl.hidden = false;
}

filesEl.addEventListener('change', () => {
  thumbsEl.innerHTML = '';
  [...filesEl.files].slice(0,4).forEach(f=>{
    const url = URL.createObjectURL(f);
    const img = document.createElement('img');
    img.src = url; img.className = 'thumb';
    thumbsEl.appendChild(img);
  });
});

function newRunId(userId){
  const r = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
  return `${userId}-${Date.now()}-${r}`;
}

/* ---------- IMAGE PREP: HEIC/JPEG orientation + optional center-crop ---------- */

// Map KIE token -> aspect ratio (width/height)
function ratioFromToken(tok){
  if (!tok || tok === 'auto') return null;
  const [w,h] = tok.split(':').map(Number);
  if (!w || !h) return null;
  return w / h;
}

// draw source bitmap onto a new canvas with an EXIF-aware transform
async function drawOrientedToCanvas(file, orientation){
  const bmp = await createImageBitmap(file);
  const rotated = [5,6,7,8].includes(orientation);
  const c = document.createElement('canvas');
  c.width = rotated ? bmp.height : bmp.width;
  c.height = rotated ? bmp.width : bmp.height;
  const ctx = c.getContext('2d');

  switch (orientation) {
    case 2: ctx.translate(c.width,0); ctx.scale(-1,1); break;               // flip X
    case 3: ctx.translate(c.width,c.height); ctx.rotate(Math.PI); break;    // 180
    case 4: ctx.translate(0,c.height); ctx.scale(1,-1); break;              // flip Y
    case 5: ctx.rotate(.5*Math.PI); ctx.scale(1,-1); ctx.translate(0,-c.width); break;
    case 6: ctx.rotate(.5*Math.PI); ctx.translate(0,-c.height); break;      // 90 CW
    case 7: ctx.rotate(.5*Math.PI); ctx.scale(-1,1); ctx.translate(-c.width,-c.height); break;
    case 8: ctx.rotate(-.5*Math.PI); ctx.translate(-c.height,0); break;     // 90 CCW
    default: /* 1 = no rotation */;
  }
  ctx.drawImage(bmp, 0, 0);
  return c;
}

// Center-crop a canvas to the requested ratio ("cover" behavior)
function cropCanvasToRatio(canvas, targetRatio){
  if (!targetRatio) return canvas;
  const w = canvas.width, h = canvas.height, r = w / h;
  if (Math.abs(r - targetRatio) < 0.002) return canvas; // close enough

  let sx=0, sy=0, sw=w, sh=h;
  if (r > targetRatio) {
    // too wide -> crop width
    sw = Math.round(h * targetRatio);
    sx = Math.floor((w - sw) / 2);
  } else {
    // too tall -> crop height
    sh = Math.round(w / targetRatio);
    sy = Math.floor((h - sh) / 2);
  }
  const out = document.createElement('canvas');
  out.width = sw; out.height = sh;
  const ctx = out.getContext('2d');
  ctx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
  return out;
}

// Prepare final uploadable file: convert HEIC -> JPEG, rotate by EXIF, optional crop
async function prepareImageForUpload(file, desiredToken){
  const isHeic = /image\/hei(c|f)/i.test(file.type);
  let orientation = 1;
  try { orientation = await exifr.orientation(file) || 1; } catch {}

  let working = file;

  if (isHeic) {
    // Convert first
    const base = (file.name?.replace(/\.[^.]+$/, '') || 'image');
    const blob = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.95 });
    working = new File([blob], base + '.jpg', { type: 'image/jpeg' });
    // Keep the orientation we read from the *original* HEIC
  }

  // Apply orientation if needed
  if (orientation && orientation !== 1) {
    const c = await drawOrientedToCanvas(working, orientation);
    working = await new Promise(res => c.toBlob(b => res(new File([b], (working.name||'image').replace(/\.[^.]+$/, '.jpg'), { type: 'image/jpeg' })), 'image/jpeg', 0.95));
  }

  // Optional center-crop to requested ratio (prevents KIE black bars)
  const targetRatio = ratioFromToken(desiredToken);
  if (targetRatio) {
    const c = await drawOrientedToCanvas(working, 1);
    const cropped = cropCanvasToRatio(c, targetRatio);
    working = await new Promise(res => cropped.toBlob(b => res(new File([b], (working.name||'image').replace(/\.[^.]+$/, '.jpg'), { type: 'image/jpeg' })), 'image/jpeg', 0.95));
  }

  return working;
}
/* --------------------------------------------------------------------------- */

/* multipart upload */
async function uploadViaFn(file, rid, index, sizeToken){
  // Prepare (HEIC fix + EXIF rotate + optional crop)
  let prepared = file;
  try {
    prepared = await prepareImageForUpload(file, sizeToken);
  } catch (e) {
    // If prep fails, fall back to original file (still uploaded)
    console.warn('prep failed, falling back:', e);
  }

  const fd = new FormData();
  fd.append('file', prepared, `${rid}-${index}-${prepared.name || 'image'}`);
  fd.append('run_id', rid);

  const res = await fetch('/.netlify/functions/kie-upload', { method: 'POST', body: fd });
  const j = await res.json().catch(()=>null);
  if (!res.ok || !j || !j.downloadUrl) {
    throw new Error((j && j.error) ? j.error : `kie-upload failed (${res.status})`);
  }
  return j.downloadUrl;
}

window.__run = async function(){
  if (runBtn.disabled || runBtn.dataset.busy === '1') return;
  const files = [...filesEl.files];
  if (!files.length) { alert('Choose at least one image.'); return; }
  if (files.length > 4) { alert('Max 4 images.'); return; }
  for (const f of files){ if (f.size > 10*1024*1024){ alert(`"${f.name}" exceeds 10MB.`); return; } }

  const oldText = runBtn.textContent;
  statusEl.hidden = true;
  runBtn.dataset.busy = '1';
  runBtn.disabled = true; runBtn.textContent = 'Working…';
  try {
    const tg = window.Telegram?.WebApp;
    const deepUid = new URLSearchParams(location.search).get('uid') || '';
    const userId = tg?.initDataUnsafe?.user?.id || deepUid || `web-${Math.random().toString(36).slice(2,8)}`;
    const run_id = newRunId(userId);

    const urls = [];
    const sizeToken = (imageSizeEl?.value || 'auto');   // KIE tokens: auto, 1:1, 3:4, 9:16, 4:3, 16:9
    for (let i=0;i<files.length;i++){
      const u = await uploadViaFn(files[i], run_id, i, sizeToken);
      urls.push(u);
    }
    if (!urls.length){
      showStatus('❌ No images uploaded. Try JPEG/PNG/WebP.', 'err');
      return;
    }

    const payload = {
      prompt: ((promptEl.value ?? '').toString().replace(/\u00A0/g,' ').trim()) || '.',
      format: (formatEl.value || 'png').toLowerCase(),
      image_size: sizeToken,
      imageUrls: urls,
      uid: userId,
      run_id
    };

    const res = await fetch('/.netlify/functions/kie-create' + `?rid=${encodeURIComponent(run_id)}&t=${Date.now()}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-store' },
      body: JSON.stringify(payload)
    });

    const txt = await res.text();
    try {
      const j = JSON.parse(txt);
      const data = j?.data || j?.response?.data || {};
      const taskId   = data.taskId || data.id || '';
      const recordId = data.recordId || '';
      if (taskId || recordId) {
        showStatus('✅ Submitted successfully. If you have enough credits, your image will be delivered in Telegram within ~30 seconds.\n\n✅ Запрос успешно принят. Если у вас достаточно кредитов, изображение будет доставлено в Telegram в течение ~30 секунд.', 'ok');
      } else {
        showStatus('✅ Submitted. Check Telegram for the result.', 'ok');
      }
    } catch {
      // plain text -> ignore
    }
  } catch (err) {
    log('RUN ERROR:', String(err));
    showStatus('❌ ' + String(err.message || err), 'err');
  } finally {
    runBtn.textContent = oldText; runBtn.disabled = false; runBtn.dataset.busy='';
  }
};
</script>
</body>
</html>
