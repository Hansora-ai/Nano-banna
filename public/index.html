<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nano Banana — Image-to-Image</title>

  <!-- CSP that allows inline JS + the endpoints we call -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 img-src * data: blob:;
                 connect-src 'self' https://api.kie.ai https://kieai.redpandaai.co https://hook.make.com;
                 style-src 'self' 'unsafe-inline';
                 script-src 'self' 'unsafe-inline'">

  <style>
    body { background:#0b0b0f; color:#eaeaf0; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { max-width:880px; margin:40px auto; padding:24px; background:#14141b; border-radius:16px; box-shadow:0 8px 28px rgba(0,0,0,.45); }
    h1 { font-weight:700; font-size:24px; margin:0 0 12px; }
    .row{display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap}
    .col{flex:1 1 320px}
    label{display:block; font-size:13px; opacity:.85; margin-bottom:6px}
    input[type="file"], textarea, select { width:100%; background:#0f0f15; color:#eaeaf0; border:1px solid #262634; border-radius:12px; padding:10px 12px; }
    textarea{min-height:120px; resize:vertical}
    button{width:100%; padding:12px 16px; background:#6b5bd1; color:#fff; border:0; border-radius:12px; font-weight:600; cursor:pointer}
    button[disabled]{opacity:.6; cursor:not-allowed}
    .thumb{margin-top:8px; width:160px; height:160px; object-fit:cover; border-radius:10px; border:1px solid #262634}
    details{margin-top:16px; background:#0f0f15; border:1px solid #262634; border-radius:12px; padding:10px 12px}
    pre{white-space:pre-wrap; word-break:break-word; margin:0}
    .note{font-size:12px; opacity:.7; margin-top:6px}
  </style>
</head>
<body>
  <noscript><div style="background:#ffdbdb;color:#300;padding:10px;border-radius:8px">
    JavaScript is disabled. The Run button won’t work.
  </div></noscript>

  <div class="wrap">
    <h1>Nano Banana — Image-to-Image</h1>

    <div class="row">
      <div class="col">
        <label for="files">Select 1–4 images (jpeg/png/webp, ≤10MB each)</label>
        <input id="files" type="file" accept="image/*" multiple />
        <div id="thumbs"></div>
        <div class="note">
          Sends <b>JSON</b> to <code>/.netlify/functions/kie-create</code>. KIE posts the final result to your Make.com webhook.
        </div>
      </div>

      <div class="col">
        <label for="prompt">Prompt</label>
        <textarea id="prompt" placeholder="Describe the edit or style…"></textarea>
        <div style="height:10px"></div>
        <label for="format">Output format</label>
        <select id="format">
          <option value="png" selected>PNG</option>
          <option value="jpeg">JPEG</option>
        </select>
        <div style="height:14px"></div>
        <!-- Inline click calls the handler; no alert -->
        <button id="runBtn" type="button"
                onclick="window.__run && window.__run()">Run</button>
      </div>
    </div>

    <details open>
      <summary>Debug</summary>
      <pre id="debug">BOOT: page parsed.</pre>
    </details>
  </div>

<script>
/* ===================== DEBUG & ELEMENTS ===================== */
const dbg = document.getElementById('debug');
const log = (...a) => { dbg.textContent += '\n' + a.map(x=>typeof x==='string'?x:JSON.stringify(x,null,2)).join(' '); };

window.addEventListener('error', e => log('Window error:', e.message));
window.addEventListener('unhandledrejection', e => log('Unhandled promise:', String(e.reason)));

const filesEl = document.getElementById('files');
const thumbsEl= document.getElementById('thumbs');
const promptEl= document.getElementById('prompt');
const formatEl= document.getElementById('format');
const runBtn  = document.getElementById('runBtn');

log('BOOT: elements wired.');

/* ===================== THUMBNAILS ===================== */
filesEl.addEventListener('change', () => {
  thumbsEl.innerHTML = '';
  [...filesEl.files].slice(0,4).forEach(f=>{
    const url = URL.createObjectURL(f);
    const img = document.createElement('img');
    img.src = url; img.className = 'thumb';
    thumbsEl.appendChild(img);
  });
});

/* ===================== HELPERS ===================== */
async function fileToBase64(file){
  const ab = await file.arrayBuffer();
  let bin=''; const bytes=new Uint8Array(ab), step=0x8000;
  for (let i=0;i<bytes.length;i+=step) bin += String.fromCharCode.apply(null, bytes.subarray(i,i+step));
  return btoa(bin);
}

/* >>> REPLACED: preserve quality; only compress if absolutely necessary */
async function prepareFileForUpload(file){
  const SAFE_BASE64_CHARS = 7_500_000;   // ~5.6 MB binary; keeps request body safe on mobile
  const PNG_MAXSIDE_STEP1 = Infinity;    // full-size lossless first
  const PNG_MAXSIDE_STEP2 = 2400;        // gentle downscale, still PNG/lossless
  const JPG_MAXSIDE       = 2000;        // last resort
  const JPG_QUALITIES     = [0.92, 0.88, 0.82]; // high -> medium

  // 0) Try original as-is if small enough
  if ((file.size || 0) <= 5 * 1024 * 1024) { // <=5MB binary ≈ <=6.7MB base64
    return { name: file.name, contentType: file.type || 'application/octet-stream', data: await fileToBase64(file) };
  }

  // helper to draw and export PNG/JPEG at given max side / quality
  async function drawExport({type, maxSide=Infinity, quality=null}){
    const url = URL.createObjectURL(file);
    const img = await new Promise((res, rej) => { const i = new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=url; });
    let w = img.naturalWidth, h = img.naturalHeight;
    if (isFinite(maxSide)) {
      if (w > h && w > maxSide) { h = Math.round(h * (maxSide / w)); w = maxSide; }
      else if (h >= w && h > maxSide) { w = Math.round(w * (maxSide / h)); h = maxSide; }
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.getContext('2d').drawImage(img, 0, 0, w, h);
    const dataURL = type === 'image/png' ? c.toDataURL('image/png') : c.toDataURL('image/jpeg', quality ?? 0.92);
    const base64  = dataURL.split(',')[1];
    const name    = (file.name || 'image').replace(/\.[^.]+$/,'') + (type==='image/png'?'.png':'.jpg');
    return { name, contentType: type, data: base64 };
  }

  // 1) Lossless PNG at full size
  try {
    let out = await drawExport({ type: 'image/png', maxSide: PNG_MAXSIDE_STEP1 });
    if (out.data.length <= SAFE_BASE64_CHARS) return out;

    // 2) Gentle lossless downscale (PNG)
    out = await drawExport({ type: 'image/png', maxSide: PNG_MAXSIDE_STEP2 });
    if (out.data.length <= SAFE_BASE64_CHARS) return out;

    // 3) Last resort: high-quality JPEG with moderate downscale
    for (const q of JPG_QUALITIES) {
      out = await drawExport({ type: 'image/jpeg', maxSide: JPG_MAXSIDE, quality: q });
      if (out.data.length <= SAFE_BASE64_CHARS) return out;
    }
    // If still huge, return best we got (last JPEG)
    return out;
  } catch {
    // On any failure, fall back to original
    return { name: file.name, contentType: file.type || 'application/octet-stream', data: await fileToBase64(file) };
  }
}

/* ===================== MAIN RUN ===================== */
window.__run = async function(){
  log('RUN: clicked (handler).');
  const files = [...filesEl.files];
  if (!files.length) { alert('Choose at least one image.'); return; }
  if (files.length > 4) { alert('Max 4 images.'); return; }
  for (const f of files){ if (f.size > 10*1024*1024){ alert(`"${f.name}" exceeds 10MB.`); return; } }

  const oldText = runBtn.textContent;
  runBtn.disabled = true; runBtn.textContent = 'Working…';
  try {
    const payload = {
      prompt: ((promptEl.value ?? '').toString().replace(/\u00A0/g,' ').trim()) || '.',
      format: (formatEl.value || 'png').toLowerCase(),
      files: await Promise.all(files.map(prepareFileForUpload))
    };

    const res = await fetch('/.netlify/functions/kie-create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const ct  = res.headers.get('content-type') || '';
    const txt = await res.text();
    log(`CREATE: status=${res.status} ct=${ct}`);
    try {
      const j = JSON.parse(txt);
      log('CREATE JSON:', j);
      const data = j?.data || j?.response?.data || {};
      const taskId   = data.taskId || data.id || '';
      const recordId = data.recordId || '';
      if (taskId || recordId) log('SUBMITTED ✔  Watch your Make webhook for the result.', { taskId, recordId });
    } catch { log('CREATE TEXT:', txt); }
  } catch (err) {
    log('RUN ERROR:', String(err));
    alert('Request failed. See Debug.');
  } finally {
    runBtn.textContent = oldText; runBtn.disabled = false;
  }
};

/* (no extra bindings; the inline onclick calls __run) */
log('BOOT: handler attached.');
</script>
</body>
</html>
