<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HANSORA • Kling 2.6 Motion Control • Telegram</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='16' fill='%23111827'/%3E%3Ctext x='50%25' y='52%25' font-size='32' text-anchor='middle' fill='white' font-family='Arial'%3EH%3C/text%3E%3C/svg%3E" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://qmaealblegvcwodlmeht.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFtYWVhbGJsZWd2Y3dvZGxtZWh0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2MjkzNzMsImV4cCI6MjA3NDIwNTM3M30.bUV6W0zBtkd_6gtfPGBSpskybUmpLC-1znljoDpYy4c";
    if (window.supabase && typeof window.supabase.createClient === "function") {
      window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }
  </script>
  <style>
    :root{
      --base-bg:#0b0d13;
      --base-line:#1a1f2b;
      --brand:#6366f1;
    }
    body{
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(99,102,241,.15), transparent 60%),
        radial-gradient(1200px 600px at 100% 100%, rgba(56,189,248,.12), transparent 60%),
        var(--base-bg);
      color:#e5e7eb;
    }
    .shadow-soft{box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .input-dark{background:rgba(255,255,255,.05)!important;color:#e5e7eb!important;border:1px solid rgba(255,255,255,.12)!important}
    .input-dark::placeholder{color:#9ca3af}
    select.input-dark option{background:#0b0d13;color:#e5e7eb}
    .bg-base-bg{background:var(--base-bg)}
    .border-base-line{border-color:var(--base-line)}
    .btn{
      background:linear-gradient(135deg,#4f46e5,#6366f1);
      color:white;
    }
    .btn:disabled{opacity:.5;cursor:not-allowed;}
  </style>
</head>

<body class="min-h-screen flex flex-col bg-base-bg">
  <header class="border-b border-base-line/60">
    <div class="max-w-4xl mx-auto px-4 py-3 flex items-center justify-between gap-3">
      <div class="flex items-center gap-2">
        <div class="h-8 w-8 rounded-2xl bg-indigo-500 flex items-center justify-center text-sm font-bold shadow-lg shadow-indigo-500/40">H</div>
        <div class="flex flex-col leading-tight">
          <span class="text-sm font-semibold text-white">Hansora AI</span>
          <span class="text-xs text-zinc-400">Kling 2.6 Motion Control</span>
        </div>
      </div>
      <div class="flex items-center gap-3 text-xs">
        <div class="px-3 py-1 rounded-full border border-base-line bg-black/40">
          <span class="text-zinc-400">Credits:</span>
          <span id="creditsDisplay" class="font-semibold text-emerald-300 ml-1">0⚡</span>
        </div>
      </div>
    </div>
  </header>

  <main class="flex-1">
    <div class="max-w-4xl mx-auto px-4 py-6 space-y-6">
      <section class="rounded-2xl p-5 border border-white/10 shadow-soft bg-white/5 space-y-4">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h1 class="text-lg md:text-xl font-semibold text-white">Kling 2.6 Motion Control</h1>
            <p class="text-xs md:text-sm text-zinc-400 mt-1">
              Upload a character image and a motion video, add a prompt, and get an AI video.
            </p>
          </div>
        </div>

        <div class="grid md:grid-cols-[1.1fr,0.9fr] gap-4 md:gap-6 items-start">
          <div class="space-y-4">
            <div class="flex flex-row gap-4">
              <div class="flex-1 space-y-2">
                <label class="block text-xs font-medium text-zinc-300 mb-1">Character image (required)</label>
                <input
                  id="imageInput"
                  type="file"
                  accept="image/*"
                  class="input-dark block w-full text-xs file:mr-3 file:py-2 file:px-3 file:rounded-lg file:border-0 file:text-xs file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-400"
                />
                <div id="imageThumbs" class="mt-2 flex gap-2 flex-wrap"></div>
              </div>

              <div class="flex-1 space-y-2">
                <label class="block text-xs font-medium text-zinc-300 mb-1">Motion video (required)</label>
                <input
                  id="videoInput"
                  type="file"
                  accept="video/*"
                  class="input-dark block w-full text-xs file:mr-3 file:py-2 file:px-3 file:rounded-lg file:border-0 file:text-xs file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-400"
                />
                <div id="videoThumbs" class="mt-2 flex gap-2 flex-wrap"></div>
              </div>
            </div>

            <p class="text-[11px] text-zinc-500">
              Image max 10MB. Video max 100MB, up to 30s. Both inputs are required. Video preview shows the first frame.</p>

            <div class="space-y-2">
              <label class="block text-xs font-medium text-zinc-300 mb-1">Prompt (required)</label>
              <textarea
                id="promptInput"
                rows="4"
                class="input-dark w-full text-xs rounded-xl px-3 py-2 text-zinc-100 placeholder:text-zinc-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                placeholder="Example: The cartoon character is dancing."></textarea>
              <p class="text-[11px] text-zinc-500">
                Required. Describe the desired motion / transformation.
              </p>
            </div>

            <div class="rounded-2xl border border-base-line bg-black/30 px-4 py-3">
              <div class="flex items-center justify-between text-xs">
                <div class="text-zinc-400">
                  Quality:
                  <select id="qualitySelect" class="input-dark text-xs rounded-lg px-2 py-1 ml-1">
                    <option value="1080p" selected>1080p</option>
                    <option value="720p">720p</option>
                  </select>
                </div>
                <div class="text-zinc-400">
                  Video duration:
                  <span id="videoDurationLabel" class="text-zinc-200 font-semibold ml-1">—</span>
                </div>
              </div>
              <div class="mt-2 text-xs text-zinc-400">
                Cost:
                <span id="costLabel" class="text-emerald-300 font-semibold ml-1">—</span>
                <span class="text-zinc-500 ml-1">(<span id="rateLabel">1⚡</span> per second)</span>
              </div>
            </div>

            <div class="space-y-2">
              <button
                id="runBtn"
                class="btn w-full rounded-2xl px-4 py-3 text-sm font-semibold shadow-lg shadow-indigo-500/40">
                Run
              </button>
              <p id="statusText" class="text-[11px] text-zinc-500">Ready.</p>
            </div>

            <div id="successBox" class="mt-3 hidden">
              <div class="rounded-2xl border border-emerald-500 bg-emerald-900/80 px-4 py-3 text-emerald-50 text-sm md:text-base leading-snug">
                <div class="flex items-start gap-2">
                  <div class="text-2xl">✅</div>
                  <div id="successText" class="flex-1"></div>
                </div>
              </div>
            </div>

          </div>

          <div class="space-y-3">
            <div class="rounded-2xl border border-base-line bg-black/40 p-3 md:p-4">
              <h2 class="text-xs font-semibold text-zinc-200 mb-1">Instructions</h2>
              <ol class="list-decimal list-inside text-[11px] text-zinc-400 space-y-1.5">
                <li>Upload a character image (required).</li>
                <li>Upload a motion video (required).</li>
                <li>Type your prompt.</li>
                <li>Cost is calculated from your video duration (<span id="rateLabel">1⚡</span> per second).</li>
                <li>Click Run. If you have enough credits, the result will be sent to your bot's chat.</li>
              </ol>
            </div>
          </div>

        </div>
      </section>
    </div>
  </main>

  <script>
    let telegramId = "";
    let credits = 0;
    let mode = "";
    let leng = "";

    const creditsDisplay = document.getElementById("creditsDisplay");
    const statusText = document.getElementById("statusText");
    const successBox = document.getElementById("successBox");
    const successText = document.getElementById("successText");
    const runBtn = document.getElementById("runBtn");

    const imageInput = document.getElementById("imageInput");
    const videoInput = document.getElementById("videoInput");
    const imageThumbsEl = document.getElementById("imageThumbs");
    const videoThumbsEl = document.getElementById("videoThumbs");
    const promptInput = document.getElementById("promptInput");

    const videoDurationLabel = document.getElementById("videoDurationLabel");
    const costLabel = document.getElementById("costLabel");
    const qualitySelect = document.getElementById("qualitySelect");
    const rateLabel = document.getElementById("rateLabel");

    let lastImageObjURL = null;
    let lastVideoObjURL = null;

    let videoDurationSeconds = null;
    let computedCost = null;

    let qualityMode = "1080p";
    let ratePerSecond = 1;

    function setStatus(msg, tone){
      statusText.textContent = msg;
      statusText.className = "text-[11px] " + (tone || "text-zinc-500");
    }

    function repaintCredits(){
      creditsDisplay.textContent = credits.toFixed(1).replace(/\.0$/, "") + "⚡";
    }

    function computeBillableSeconds(d){
      const dur = Number(d||0);
      if (!isFinite(dur) || dur <= 0) return 0;
      const rounded = Math.round(dur);
      if (Math.abs(dur - rounded) < 0.20) return Math.max(1, rounded);
      // Tolerate tiny encoder overhangs, e.g. 5.01s should bill as 5s
      return Math.max(1, Math.ceil(dur - 0.05));
    }

    function updateRateFromQuality(){
      qualityMode = (qualitySelect && qualitySelect.value) ? qualitySelect.value : "1080p";
      ratePerSecond = (qualityMode === "720p") ? 0.5 : 1;
      if (rateLabel) rateLabel.textContent = ratePerSecond.toString().replace(/\.0$/, "") + "⚡";
    }

    function formatCost(c){
      if (!isFinite(c)) return "—";
      // show .5 only when needed
      if (Math.abs(c - Math.round(c)) < 1e-9) return String(Math.round(c));
      return c.toFixed(1).replace(/\.0$/, "");
    }

    function updateCostUI(){
      updateRateFromQuality();

      if (!videoDurationSeconds || !isFinite(videoDurationSeconds) || videoDurationSeconds <= 0) {
        videoDurationLabel.textContent = "—";
        costLabel.textContent = "—";
        computedCost = null;
        updateRunButtonLabel();
        return;
      }

      const billableSec = computeBillableSeconds(videoDurationSeconds);
      if (!billableSec){
        videoDurationLabel.textContent = "—";
        costLabel.textContent = "—";
        computedCost = null;
        updateRunButtonLabel();
        return;
      }

      computedCost = billableSec * ratePerSecond;
      videoDurationLabel.textContent = billableSec + "s";
      costLabel.textContent = formatCost(computedCost) + "⚡";
      updateRunButtonLabel();
    }

    function updateRunButtonLabel(){
      if (!runBtn) return;
      if (!computedCost){
        runBtn.textContent = "Run";
        return;
      }
      runBtn.textContent = "Run (cost: " + (typeof formatCost==="function" ? formatCost(computedCost) : computedCost) + "⚡)";
    }

    function clearImageSelection(){
      try {
        if (lastImageObjURL) {
          URL.revokeObjectURL(lastImageObjURL);
          lastImageObjURL = null;
        }
      } catch {}
      if (imageInput) imageInput.value = "";
      if (imageThumbsEl) imageThumbsEl.innerHTML = "";
    }

    function clearVideoSelection(){
      try {
        if (lastVideoObjURL) {
          URL.revokeObjectURL(lastVideoObjURL);
          lastVideoObjURL = null;
        }
      } catch {}
      if (videoInput) videoInput.value = "";
      if (videoThumbsEl) videoThumbsEl.innerHTML = "";
      videoDurationSeconds = null;
      computedCost = null;
      updateCostUI();
    }

    async function loadVideoFirstFramePreview(videoUrl){
      // Captures first frame into an <img> (canvas snapshot)
      return await new Promise((resolve, reject) => {
        const v = document.createElement("video");
        v.preload = "metadata";
        v.muted = true;
        v.playsInline = true;
        v.src = videoUrl;

        const cleanup = () => {
          v.removeAttribute("src");
          try { v.load(); } catch {}
        };

        v.addEventListener("loadedmetadata", () => {
          // Duration available here
          const d = Number(v.duration);
          if (isFinite(d) && d > 0) {
            videoDurationSeconds = d;
            updateCostUI();
          }
          try {
            // Seek to near-zero to ensure frame is ready
            v.currentTime = Math.min(0.05, Math.max(0, d ? d - 0.001 : 0));
          } catch (e) {
            // If seeking fails, still try draw on loadeddata
          }
        });

        v.addEventListener("seeked", () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = v.videoWidth || 640;
            canvas.height = v.videoHeight || 360;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL("image/jpeg", 0.85);
            cleanup();
            resolve(dataUrl);
          } catch (e) {
            cleanup();
            reject(e);
          }
        });

        v.addEventListener("error", () => {
          cleanup();
          reject(new Error("Could not read video metadata/preview."));
        });
      });
    }

    if (imageInput && imageThumbsEl){
      imageInput.addEventListener("change", () => {
        imageThumbsEl.innerHTML = "";
        try {
          if (lastImageObjURL) {
            URL.revokeObjectURL(lastImageObjURL);
            lastImageObjURL = null;
          }
        } catch {}
        const f = imageInput.files && imageInput.files[0];
        if (!f) return;

        if (f.size > 10 * 1024 * 1024){
          clearImageSelection();
          setStatus("Image file too large (max 10MB).", "text-rose-300");
          return;
        }

        const u = URL.createObjectURL(f);
        lastImageObjURL = u;

        const img = new Image();
        img.src = u;
        img.className = "block w-full max-h-56 object-contain rounded-lg border border-white/10 bg-black/20";

        const wrap = document.createElement("div");
        wrap.className = "relative inline-block";

        const del = document.createElement("button");
        del.type = "button";
        del.className = "absolute -top-2 -right-2 h-7 w-7 rounded-full bg-black/70 border border-white/20 text-white/80 hover:text-white hover:bg-black/90 flex items-center justify-center";
        del.innerHTML = "\u00d7";
        del.onclick = clearImageSelection;

        wrap.appendChild(img);
        wrap.appendChild(del);
        imageThumbsEl.appendChild(wrap);
      });
    }

    if (videoInput && videoThumbsEl){
      videoInput.addEventListener("change", async () => {
        videoThumbsEl.innerHTML = "";
        videoDurationSeconds = null;
        computedCost = null;
        updateCostUI();

        try {
          if (lastVideoObjURL) {
            URL.revokeObjectURL(lastVideoObjURL);
            lastVideoObjURL = null;
          }
        } catch {}

        const f = videoInput.files && videoInput.files[0];
        if (!f) return;

        if (f.size > 100 * 1024 * 1024){
          clearVideoSelection();
          setStatus("Video file too large (max 100MB).", "text-rose-300");
          return;
        }

        const u = URL.createObjectURL(f);
        lastVideoObjURL = u;

        // Reliable preview across in-app browsers: use a real <video> element (not canvas snapshot)
        const wrap = document.createElement("div");
        wrap.className = "relative inline-block w-full";

        const v = document.createElement("video");
        v.src = u;
        v.muted = true;
        v.playsInline = true;
        v.preload = "metadata";
        v.controls = true;
        v.className = "block w-full max-h-56 object-contain rounded-lg border border-white/10 bg-black/20";

        const del = document.createElement("button");
        del.type = "button";
        del.className = "absolute -top-2 -right-2 h-7 w-7 rounded-full bg-black/70 border border-white/20 text-white/80 hover:text-white hover:bg-black/90 flex items-center justify-center";
        del.innerHTML = "\u00d7";
        del.onclick = clearVideoSelection;

        wrap.appendChild(v);
        wrap.appendChild(del);
        videoThumbsEl.appendChild(wrap);

        setStatus("Reading video duration…", "text-zinc-400");

        const fail = (msg) => {
          clearVideoSelection();
          setStatus(msg || "Error reading video. Please try another file.", "text-rose-300");
        };

        // Duration + first-frame seek
        v.addEventListener("loadedmetadata", () => {
          const d = Number(v.duration);
          if (isFinite(d) && d > 0) {
            videoDurationSeconds = d;
            updateCostUI();
          }
          // Seek near start to ensure first frame is shown
          try { v.currentTime = 0.01; } catch {}
        }, { once: true });

        v.addEventListener("loadeddata", () => {
          // Pause on first frame
          try { v.pause(); } catch {}
          setStatus("Ready.", "text-zinc-500");
        }, { once: true });

        v.addEventListener("error", () => {
          fail("Could not preview this video format on your device. Please export as MP4 (H.264) and try again.");
        }, { once: true });
      });
    }

    function parseQueryParams(){
      const url = new URL(window.location.href);
      telegramId = url.searchParams.get("telegram_id") || "";

      mode = url.searchParams.get("mode") || url.searchParams.get("modul") || "";
      leng = url.searchParams.get("leng") || url.searchParams.get("lang") || "";

      if (!telegramId){
        setStatus("Missing telegram_id in URL. Please open this page from the bot.", "text-rose-300");
        if (runBtn) runBtn.disabled = true;
        return;
      }

      credits = 0;
      repaintCredits();
      loadCreditsFromSupabase();
    }

    async function loadCreditsFromSupabase(){
      if (!window.supabaseClient){
        console.error("Supabase client not initialized");
        return;
      }
      try {
        const { data, error } = await window.supabaseClient
          .from("telegram_users")
          .select("credits")
          .eq("telegram_id", telegramId)
          .maybeSingle();

        if (error) {
          console.error("Error loading credits from Supabase", error);
          return;
        }

        if (data && typeof data.credits !== "undefined") {
          const parsed = Number(data.credits);
          credits = Number.isFinite(parsed) ? parsed : 0;
          repaintCredits();
        }
      } catch (e) {
        console.error("Unexpected error loading credits from Supabase", e);
      }
    }

    async function signUpload(filename, mime){
      const resp = await fetch("/.netlify/functions/sign-upload", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-USER-ID": telegramId || "tg-anon"
        },
        body: JSON.stringify({ filename, mime })
      });
      const data = await resp.json().catch(() => null);
      if (!resp.ok || !data || !data.uploadUrl || !data.publicUrl){
        throw new Error((data && data.error) || "sign-upload failed");
      }
      return data;
    }

    async function handleRun(){
      if (successBox) successBox.classList.add("hidden");
      if (runBtn.disabled) return;

      if (!telegramId){
        setStatus("Missing telegram_id, cannot continue.", "text-rose-300");
        return;
      }

      const imgFile = imageInput && imageInput.files && imageInput.files[0];
      const vidFile = videoInput && videoInput.files && videoInput.files[0];

      if (!imgFile){
        setStatus("Please upload a character image.", "text-rose-300");
        return;
      }
      if (!vidFile){
        setStatus("Please upload a motion video.", "text-rose-300");
        return;
      }

      const prompt = (promptInput.value || "").trim();
      if (!prompt){
        setStatus("Please enter a prompt.", "text-rose-300");
        return;
      }

      if (imgFile.size > 10 * 1024 * 1024){
        setStatus("Image file too large (max 10MB).", "text-rose-300");
        return;
      }
      if (vidFile.size > 100 * 1024 * 1024){
        setStatus("Video file too large (max 100MB).", "text-rose-300");
        return;
      }

      if (!computedCost){
        setStatus("Please wait until the video duration is detected.", "text-rose-300");
        return;
      }


      // Video constraints
      if (Number(videoDurationSeconds) > 30.05) {
        setStatus("Video is too long (max 30s).", "text-rose-300");
        return;
      }

      const cost = computedCost;
      if (credits < cost){
        setStatus("Not enough credits (need " + cost + ").", "text-rose-300");
        return;
      }

      runBtn.disabled = true;
      runBtn.textContent = "Working…";

      let imageUrl = "";
      let videoUrl = "";

      try {
        setStatus("Uploading image…", "text-zinc-400");
        const imgOrigName = imgFile.name || "image.jpg";
        const imgType = (imgFile.type || "image/jpeg").toLowerCase();
        const imgSafeExt = imgType.includes("png") ? ".png"
          : (imgType.includes("jpeg") || imgType.includes("jpg")) ? ".jpg"
          : (imgType.includes("webp") ? ".webp" : ".jpg");
        const imgBase = imgOrigName.replace(/\.[^./\\]+$/, "");
        const imgFilename = Date.now() + "-mc-img-" + imgBase + imgSafeExt;

        const imgSign = await signUpload(imgFilename, imgType || "image/jpeg");
        const putImg = await fetch(imgSign.uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": imgType || "image/jpeg" },
          body: imgFile
        });
        if (!putImg.ok) throw new Error("Image upload failed");
        try { await fetch(imgSign.publicUrl, { method:"HEAD", cache:"no-store" }); } catch {}
        imageUrl = imgSign.publicUrl;

        setStatus("Uploading video…", "text-zinc-400");
        const vidOrigName = vidFile.name || "motion.mp4";
        const vidType = (vidFile.type || "video/mp4").toLowerCase();
        const vidSafeExt = vidType.includes("webm") ? ".webm"
          : (vidType.includes("quicktime") ? ".mov" : ".mp4");
        const vidBase = vidOrigName.replace(/\.[^./\\]+$/, "");
        const vidFilename = Date.now() + "-mc-vid-" + vidBase + vidSafeExt;

        const vidSign = await signUpload(vidFilename, vidType || "video/mp4");
        const putVid = await fetch(vidSign.uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": vidType || "video/mp4" },
          body: vidFile
        });
        if (!putVid.ok) throw new Error("Video upload failed");
        try { await fetch(vidSign.publicUrl, { method:"HEAD", cache:"no-store" }); } catch {}
        videoUrl = vidSign.publicUrl;

        setStatus("Submitting Kling Motion Control job…", "text-zinc-400");

        const resp = await fetch("/.netlify/functions/run-kling26-motion-control-tg", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            telegram_id: telegramId,
            credits_before: credits,
            new_credits: credits - cost,
            cost,
            seconds: cost,
            video_duration_seconds: videoDurationSeconds,
            prompt,
            imageUrl,
            videoUrl,
            quality: qualityMode,
            mode,
            leng
          })
        });

        const j = await resp.json().catch(() => ({}));
        if (!resp.ok || !j.submitted){
          const err = j && (j.error || j.message);
          throw new Error(err || "Error submitting job");
        }

        const newCredits = credits - cost;
        try {
          if (window.supabaseClient) {
            const { error: updateError } = await window.supabaseClient
              .from("telegram_users")
              .update({ credits: newCredits })
              .eq("telegram_id", telegramId);
            if (updateError) console.error("Error updating credits in Supabase", updateError);
          } else {
            console.error("Supabase client not available when updating credits");
          }
        } catch (e) {
          console.error("Unexpected error updating credits in Supabase", e);
        }

        credits = newCredits;
        repaintCredits();

        setStatus("✅ Request submitted.", "text-emerald-300");
        if (successBox && successText){
          successBox.classList.remove("hidden");
          successText.innerHTML =
            "✦ Submitted successfully. You will receive the Kling Motion Control video in Telegram when it is ready.<br/>" +
            "✦ Запрос успешно принят. Вы получите Kling Motion Control видео в Telegram, когда оно будет готово.";
        }
      } catch (err) {
        console.error(err);
        setStatus("Error: " + (err && err.message ? err.message : "Something went wrong."), "text-rose-300");
      } finally {
        runBtn.disabled = false;
        updateRunButtonLabel();
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      parseQueryParams();
      updateCostUI();
      updateRunButtonLabel();

      if (qualitySelect){
        qualitySelect.addEventListener("change", () => {
          updateCostUI();
        });
      }

      runBtn.addEventListener("click", () => { handleRun(); });
    });  </script>
</body>
</html>
